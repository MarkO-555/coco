<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0044)http://www.axess.com/twilight/sock/gime.html -->
<HTML><HEAD><TITLE>Sock's GIME register reference</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2462.0" name=GENERATOR></HEAD>
<BODY text=#000000 bgColor=#d0d0d0 
background="Sock's GIME register reference_files/socktile.gif">
<H1>Sock's GIME register reference</H1>
<P><FONT size=3>People keep looking for GIME information, but it seems that 
there is no place you can find it on the web. So, I've decided to try to put 
together some GIME data so CoCo programmers could put it to good use. 
<P>The GIME is a custom chip designed to replace a number of parts from the CoCo 
1&amp;2 and also add extra CoCo 3 specific features. For now, at least, I'll 
concentrate mostly on CoCo 3 features. The CoCo 1&amp;2 features work the same 
as before, so you can probably find that information on other web sites. 
<P>
<HR>

<H2>FF90 (65424) Initialization Register 0 - INIT0</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bit 7
    <TD>COCO
    <TD>1=CoCo 1/2 compatible mode </TD>
  <TR>
    <TD>Bit 6
    <TD>MMUEN
    <TD>1=MMU enabled </TD>
  <TR>
    <TD>Bit 5
    <TD>IEN
    <TD>1=GIME chip IRQ enabled </TD>
  <TR>
    <TD>Bit 4
    <TD>FEN
    <TD>1=GIME chip FIRQ enabled </TD>
  <TR>
    <TD>Bit 3
    <TD>MC3
    <TD>1=RAM at FExx is constant<BR>(secondary vectors) </TD>
  <TR>
    <TD>Bit 2
    <TD>MC2
    <TD>1=standard SCS<BR>(spare chip select) </TD>
  <TR>
    <TD>Bits 1-0
    <TD>MC1<BR>MC0
    <TD>ROM map control<BR>0x=16K internal, 16K external<BR>10=32K 
      internal<BR>11=32K external (except interrupt vectors) 
</TD></TR></TBODY></TABLE><BR><FONT size=2>To use CoCo 3 graphics, the COCO bit 
must be set to zero. When using CoCo 1/2 resolutions, the bit is set to 1. RSDOS 
typically sets the INIT0 register to 196 in CoCo 2 resolutions and 68 when using 
CoCo 3 graphics modes. </FONT>
<P>
<HR>

<H2>FF91 (65425) Initialization Register 1 - INIT1</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bit 7
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bit 6
    <TD>?
    <TD>Memory type<BR>1=256K, 0=64K chips </TD>
  <TR>
    <TD>Bit 5
    <TD>TINS
    <TD>Timer clock source<BR>1=279.365 nsec, 0=63.695 usec </TD>
  <TR>
    <TD>Bits 4-1
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bit 0
    <TD>TR
    <TD>MMU task select<BR>1=enable FFA8-FFAF MMU registers<BR>0=enable 
      FFA0-FFA7 MMU registers </TD></TR></TBODY></TABLE><BR><FONT size=2>The TINS bit 
selects the clock speed of the countdown timer. The 279 ns clock is useful for 
interrupt driven sound routines while the 63 us clock is used for a slower 
timer. The task bit is generally set to zero in DECB.<BR>The task register 
select which set of MMU bank registers to assign to the CPU's 64K workspace. 
</FONT>
<P>
<HR>

<H2>FF92 (65426) Interrupt request enable register - IRQENR</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-6
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bit 5
    <TD>TMR
    <TD>1=Enable timer IRQ </TD>
  <TR>
    <TD>Bit 4
    <TD>HBORD
    <TD>1=Enable Horizontal border IRQ </TD>
  <TR>
    <TD>Bit 3
    <TD>VBORD
    <TD>1=Enable Vertical border IRQ </TD>
  <TR>
    <TD>Bit 2
    <TD>EI2
    <TD>1=Enable Serial data IRQ </TD>
  <TR>
    <TD>Bit 1
    <TD>EI1
    <TD>1=Enable Keyboard IRQ </TD>
  <TR>
    <TD>Bit 0
    <TD>EI0
    <TD>1=Enable Cartridge IRQ </TD></TR></TBODY></TABLE><BR><FONT size=2>TMR: An 
interrupt is generated whenever the 12 bit timer counts down to zero.<BR>HBORD: 
A horizontal border interrupt is generated on the falling edge of 
HSYNC.<BR>VBORD: A vertical border interrupt is generated on the falling edge of 
VSYNC.<BR>EI2: A serial interrupt is generated on the falling edge of the signal 
on PIN 4 of the serial port.<BR>EI1: A keyboard interrupt is generated whenever 
a zero appears on any one of PA0-PA6 on the PIA0.<BR>EI0: A cartridge interrupt 
is generated on the falling edge of the signal on PIN 8 of the cartridge 
port.<BR>Reading from the register tells you which interrupts came in and 
acknowledges and resets the interrupt source. </FONT>
<P>
<H2>FF93 (65427) Fast interrupt request enable register - FIRQENR</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-6
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bit 5
    <TD>TMR
    <TD>1=Enable timer FIRQ </TD>
  <TR>
    <TD>Bit 4
    <TD>HBORD
    <TD>1=Enable Horizontal border FIRQ </TD>
  <TR>
    <TD>Bit 3
    <TD>VBORD
    <TD>1=Enable Vertical border FIRQ </TD>
  <TR>
    <TD>Bit 2
    <TD>EI2
    <TD>1=Enable Serial data FIRQ </TD>
  <TR>
    <TD>Bit 1
    <TD>EI1
    <TD>1=Enable Keyboard FIRQ </TD>
  <TR>
    <TD>Bit 0
    <TD>EI0
    <TD>1=Enable Cartridge FIRQ </TD></TR></TBODY></TABLE><BR><FONT size=2>This 
register works the same as IRQENR except that it generates FIRQ interrupts. 
</FONT>
<P>
<HR>
<FONT size=2>Here's a table of the interrupt vectors and where they end up 
going. You can't change the $FFxx vectors, but you can change the $FExx and 
$01xx vectors which contain jmps/lbras to the interrupt routine.</FONT> 
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TH>Interrupt
    <TH>CPU reads
    <TH>which points to
    <TH>which jumps to<BR>this routine </TR>
  <TR>
    <TD>SWI3
    <TD>$FFF2
    <TD>$FEEE
    <TD>$0100 </TD>
  <TR>
    <TD>SWI2
    <TD>$FFF4
    <TD>$FEF1
    <TD>$0103 </TD>
  <TR>
    <TD>FIRQ
    <TD>$FFF6
    <TD>$FEF4
    <TD>$010F </TD>
  <TR>
    <TD>IRQ
    <TD>$FFF8
    <TD>$FEF7
    <TD>$010C </TD>
  <TR>
    <TD>SWI
    <TD>$FFFA
    <TD>$FEFA
    <TD>$0106 </TD>
  <TR>
    <TD>NMI
    <TD>$FFFC
    <TD>$FEFD
    <TD>$0109 </TD>
  <TR>
    <TD>RESET
    <TD>$FFFE
    <TD>
    <TD>$8C1B </TD></TR></TBODY></TABLE>
<HR>

<H2>FF94 (65428) Timer register MSB</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-4
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bits 3-0
    <TD>TMRH
    <TD>Timer bits 8-11 </TD></TR></TBODY></TABLE>
<H2>FF95 (65429) Timer register LSB</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-0
    <TD>TMRL
    <TD>Timer bits 0-7 </TD></TR></TBODY></TABLE><BR><FONT size=2>The 12 bit timer 
can be loaded with any number from 0-4095. The timer resets and restarts 
counting down as soon as a number is written to FF94. Writing to FF95 does not 
restart the timer, but the value does save. Reading from either register does 
not restart the timer. When the timer reaches zero, it automatically restarts 
and triggers an interrupt (if enabled). The timer also controls the rate of 
blinking text. <BR>Storing a zero to both registers stops the timer from 
operating. Lastly, the timer works slightly differently on both 1986 and 1987 
versions of the GIME. Neither can actually run a clock count of 1. That is, if 
you store a 1 into the timer register, the 1986 GIME actually processes this as 
a '3' and the 1987 GIME processes it as a '2'. All other values stored are 
affected the same way : nnn+2 for 1986 GIME and nnn+1 for 1987 GIME. </FONT>
<P>
<HR>

<H2>FF96 (65430) Reserved</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-0
    <TD>
    <TD>Unused </TD></TR></TBODY></TABLE>
<H2>FF97 (65431) Reserved</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-0
    <TD>
    <TD>Unused </TD></TR></TBODY></TABLE>
<P>
<HR>

<H2>FF98 (65432) Video mode register - VMODE</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bit 7
    <TD>BP
    <TD>1=Graphics modes<BR>0=Text modes </TD>
  <TR>
    <TD>Bit 6
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bit 5
    <TD>BPI
    <TD>1=Composite color phase invert </TD>
  <TR>
    <TD>Bit 4
    <TD>MOCH
    <TD>1=Monochrome on Composite video out </TD>
  <TR>
    <TD>Bit 3
    <TD>H50
    <TD>1=50Hz video<BR>0=60Hz video </TD>
  <TR>
    <TD>Bits 2-0
    <TD>LPR
    <TD>00x=one line per row<BR>010=two lines per row<BR>011=eight lines per 
      row<BR>100=nine lines per row<BR>101=ten lines per row<BR>110=eleven lines 
      per row<BR>111=*infinite lines per row </TD></TR></TBODY></TABLE><BR><FONT 
size=2>*Mostly useless, but it does generate a graphics mode where the whole 
screen is filled with the same line of graphics - like a 320x1 resolution. This 
can be used for a very fast oscilloscope type display where the program only 
updates data in one scan line over time and as the screen refreshes, you get a 
screen full of samples. I also used it in my Boink bouncing ball demo to take 
manual control of the vertical resolution of the screen to make the ball appear 
that it's going up and down (without actually scrolling the whole screen up and 
down).</FONT>
<P>
<HR>

<H2>FF99 (65433) Video resolution register - VRES</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bit 7
    <TD>
    <TD>Unused? </TD>
  <TR>
    <TD>Bits 6-5
    <TD>LPF
    <TD>00=192 scan lines on screen<BR>01=200 scan lines on 
      screen<BR>10=*zero/infinite lines on screen (undefined)<BR>11=225 scan 
      lines on screen </TD>
  <TR>
    <TD>Bits 4-2
    <TD>HRES
    <TD>Horizontal resolution using graphics:<BR>000=16 bytes per 
      row<BR>001=20 bytes per row<BR>010=32 bytes per row<BR>011=40 bytes per 
      row<BR>100=64 bytes per row<BR>101=80 bytes per row<BR>110=128 bytes per 
      row<BR>111=160 bytes per row<BR><BR>When using text:<BR>0x0=32 characters 
      per row<BR>0x1=40 characters per row<BR>1x0=64 characters per 
      row<BR>1x1=80 characters per row </TD>
  <TR>
    <TD>Bits 1-0
    <TD>CRES
    <TD>Color Resolution using graphics:<BR>00=2 colors (8 pixels per 
      byte)<BR>01=4 colors (4 pixels per byte)<BR>10=16 colors (2 pixels per 
      byte)<BR>11=Undefined (would have been 256 colors)<BR><BR>When using 
      text:<BR>x0=No color attributes<BR>x1=Color attributes enabled 
  </TD></TR></TBODY></TABLE><BR><FONT size=2>*The zero/infinite scanlines setting 
will either set the screen to display nothing but border (zero lines) or 
graphics going all the way up and down out of the screen, never retriggering. It 
all depends on when you set the register. If you set it while the video raster 
was drawing the vertical border you get zero lines, and if you set it while 
video was drawing graphics you get infinite lines. Mostly useless, but it should 
be possible to coax a vertical overscan mode using this with some tricky timing. 
</FONT>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TH>HRES
    <TH>CRES
    <TH>Commonly used graphics modes </TR>
  <TR>
    <TD>111
    <TD>01
    <TD>640 pixels, 4 colors </TD>
  <TR>
    <TD>101
    <TD>00
    <TD>640 pixels, 2 colors </TD>
  <TR>
    <TD>110
    <TD>01
    <TD>512 pixels, 4 colors </TD>
  <TR>
    <TD>100
    <TD>00
    <TD>512 pixels, 2 colors </TD>
  <TR>
    <TD>111
    <TD>10
    <TD>320 pixels, 16 colors </TD>
  <TR>
    <TD>101
    <TD>01
    <TD>320 pixels, 4 colors </TD>
  <TR>
    <TD>011
    <TD>00
    <TD>320 pixels, 2 colors </TD>
  <TR>
    <TD>110
    <TD>10
    <TD>256 pixels, 16 colors </TD>
  <TR>
    <TD>100
    <TD>01
    <TD>256 pixels, 4 colors </TD>
  <TR>
    <TD>010
    <TD>00
    <TD>256 pixels, 2 colors </TD>
  <TR>
    <TD>101
    <TD>10
    <TD>160 pixels, 16 colors </TD>
  <TR>
    <TD>011
    <TD>01
    <TD>160 pixels, 4 colors </TD>
  <TR>
    <TD>001
    <TD>00
    <TD>160 pixels, 2 colors </TD>
  <TR>
    <TD>100
    <TD>10
    <TD>128 pixels, 16 colors </TD>
  <TR>
    <TD>010
    <TD>01
    <TD>128 pixels, 4 colors </TD>
  <TR>
    <TD>000
    <TD>00
    <TD>128 pixels, 2 colors </TD></TR></TBODY></TABLE>
<HR>

<H2>FF9A (65434) Border color register - BRDR</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-6
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bits 5-0
    <TD>BRDR
    <TD>Border color </TD></TR></TBODY></TABLE><BR><FONT size=2>This controls the 
color of the border around the screen. The color bits work the same as the 
palette registers. This register only controls the border color of CoCo 3 video 
modes and does not affect Coco 1/2 modes. </FONT>
<P>
<HR>

<H2>FF9B (65435) Reserved</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-2
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bits 1-0
    <TD>VBANK
    <TD>Used by Disto 2 Meg upgrades to switch video between 512K banks 
  </TD></TR></TBODY></TABLE>
<P>
<HR>

<H2>FF9C (65436) Vertical scroll register - VSC</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-4
    <TD>
    <TD>Unused </TD>
  <TR>
    <TD>Bits 3-0
    <TD>VSC
    <TD>Vertical smooth scroll. </TD></TR></TBODY></TABLE><BR><FONT size=2>The 
vertical scroll register is used to allow smooth scrolling in text modes. 
Consecutive numbers scroll the screen upwards one scan line at a time in video 
modes where more than one scan line makes up a row of text (typically 8 lines 
per character row) or graphics (double height+ graphics). </FONT>
<P>
<HR>

<H2>FF9D (65437) Vertical offset register MSB</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-0
    <TD>Y15-Y8
    <TD>MSB Start of video in RAM<BR>(video location * 2048) 
</TD></TR></TBODY></TABLE><BR>
<H2>FF9E (65438) Vertical offset register LSB</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bits 7-0
    <TD>Y7-Y0
    <TD>LSB Start of video in RAM<BR>(video location * 8) 
</TD></TR></TBODY></TABLE><BR><FONT size=2>Y15-Y0 is used to set the video mode 
to start in any memory location in 512K by steps of 8 bytes. On a 128K machine, 
the memory range is $60000-$7FFFF. There is a bug in some versions of the GIME 
that causes the computer to crash when you set odd numbered values in FF9E in 
some resolutions, so it's safest to limit positioning to steps of 16 bytes. 
Fortunately, you can use FF9F to make up for it and get steps as small as 2 
bytes. </FONT>
<P>
<HR>

<H2>FF9F (65439) Horizontal offset register</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>Bit 7
    <TD>HVEN
    <TD>1=Horizontal virtual screen enable (256 bytes per row)<BR>0=Normal 
      horizontal display </TD>
  <TR>
    <TD>Bits 6-0
    <TD>X6-X0
    <TD>Horizontal offset address<BR>(video location *2) 
</TD></TR></TBODY></TABLE><BR><FONT size=2>You can combine the horintal and 
vertical offsets to get a higher definition video position: Y15-Y4,X6-X0 which 
gives you 19 bit positioning by steps of 2 bytes.<BR>Otherwise, you can use this 
register to do scrolling effects. The virtual screen mode allows you to set up a 
256 byte wide graphics or text screen, showing only part of it at a time and 
allowing you to scroll it vertically. </FONT>
<P>
<HR>

<H2>FFA0-FFA7 (65440-65447) MMU bank registers (task one)</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>FFA0
    <TD>Bank at $0000-$1FFF </TD>
  <TR>
    <TD>FFA1
    <TD>Bank at $2000-$3FFF </TD>
  <TR>
    <TD>FFA2
    <TD>Bank at $4000-$5FFF </TD>
  <TR>
    <TD>FFA3
    <TD>Bank at $6000-$7FFF </TD>
  <TR>
    <TD>FFA4
    <TD>Bank at $8000-$9FFF </TD>
  <TR>
    <TD>FFA5
    <TD>Bank at $A000-$BFFF </TD>
  <TR>
    <TD>FFA6
    <TD>Bank at $C000-$DFFF </TD>
  <TR>
    <TD>FFA7
    <TD>Bank at $E000-$FFFF<BR>(or $E000-$FDFF if secondary vectors enabled) 
    </TD></TR></TBODY></TABLE><BR><FONT size=2>These MMU registers are enabled when 
the task bit (FF91) is clear. These MMU registers allocate chunks of 8K into the 
CPU's 64K workspace. Valid bank ranges are 56-63 on 128K machines, 0-63 on 512K 
machines, 0-127 on 1Meg machines and 0-255 on 2Meg machines.<BR>These registers 
can be read, but the upper 2 bits must be masked out as they return bleedover 
from the bus (sometimes zero, sometimes one). This is okay for machines with 
512K or less, but poses a problem for 1Meg and up. Supposedly some memory 
upgrades fixed this, but most don't so you can't rely on those 2 bits to be 
there when you read the registers.</FONT>
<P>
<H2>FFA8-FFAF (65448-65455) MMU bank registers (task two)</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>FFA8
    <TD>Bank at $0000-$1FFF </TD>
  <TR>
    <TD>FFA9
    <TD>Bank at $2000-$3FFF </TD>
  <TR>
    <TD>FFAA
    <TD>Bank at $4000-$5FFF </TD>
  <TR>
    <TD>FFAB
    <TD>Bank at $6000-$7FFF </TD>
  <TR>
    <TD>FFAC
    <TD>Bank at $8000-$9FFF </TD>
  <TR>
    <TD>FFAD
    <TD>Bank at $A000-$BFFF </TD>
  <TR>
    <TD>FFAE
    <TD>Bank at $C000-$DFFF </TD>
  <TR>
    <TD>FFAF
    <TD>Bank at $E000-$FFFF<BR>(or $E000-$FDFF if secondary vectors enabled) 
    </TD></TR></TBODY></TABLE><BR><FONT size=2>These MMU registers are enabled when 
the task bit (FF91) is set. These are primarily used by the operating 
system.</FONT>
<P>
<HR>

<H2>FFB0-FFBF (65456-65471) Color palette registers</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>FFB0
    <TD>Color 0
    <TD>Bits 7-6 Unused<BR>Bit 5 = High order Red<BR>Bit 4 = High order 
      Green<BR>Bit 3 = High order Blue<BR>Bit 2 = Low order Red<BR>Bit 1 = Low 
      order Green<BR>Bit 0 = Low order Blue </TD>
  <TR>
    <TD>FFB1
    <TD>Color 1
    <TD>same as above </TD>
  <TR>
    <TD>FFB2
    <TD>Color 2
    <TD>... </TD>
  <TR>
    <TD>FFB3
    <TD>Color 3
    <TD></TD>
  <TR>
    <TD>FFB4
    <TD>Color 4
    <TD></TD>
  <TR>
    <TD>FFB5
    <TD>Color 5
    <TD></TD>
  <TR>
    <TD>FFB6
    <TD>Color 6
    <TD></TD>
  <TR>
    <TD>FFB7
    <TD>Color 7
    <TD></TD>
  <TR>
    <TD>FFB8
    <TD>Color 8
    <TD></TD>
  <TR>
    <TD>FFB9
    <TD>Color 9
    <TD></TD>
  <TR>
    <TD>FFBA
    <TD>Color 10
    <TD></TD>
  <TR>
    <TD>FFBB
    <TD>Color 11
    <TD></TD>
  <TR>
    <TD>FFBC
    <TD>Color 12
    <TD></TD>
  <TR>
    <TD>FFBD
    <TD>Color 13
    <TD></TD>
  <TR>
    <TD>FFBE
    <TD>Color 14
    <TD></TD>
  <TR>
    <TD>FFBF
    <TD>Color 15
    <TD></TD></TR></TBODY></TABLE><BR><FONT size=2>The color set when using 
composite monitors is different than above (which applies to RGB monitors). On 
composite displays, Bits 5-4 control 4 levels of intensity, and bits 3-0 control 
16 hues of color. 
<P>These registers can also be read to determine what palettes are set but like 
the MMU registers, the upper 2 bits must be masked out. Both reading and writing 
to the palette registers causes a small 'glitch' on the screen. If you want to 
avoid them, you can change the palettes while the video is in the vertical or 
horizontal border. <BR>On the other hand, you could also generate the glitches 
on purpose, to superimpose snow on the screen. The glitches appear as the color 
you set the register to (with a bit of the previous color setting at the 
beginning) and with precise CPU timing loops you could actually superimpose 
definable graphics over the screen this way. </FONT>
<P>
<HR>

<H2>FFD8/FFD9 (65496/65497) CPU clock rate</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>FFD8
    <TD>'Slow poke'
    <TD>Any write selects 0.89 Mhz CPU clock </TD>
  <TR>
    <TD>FFD9
    <TD>'Fast poke'
    <TD>Any write selects 1.79 Mhz CPU clock </TD></TR></TBODY></TABLE>
<P>
<HR>

<H2>FFDE/FFDF (65502/65503) ROM/RAM map type</H2>
<P>
<TABLE cellSpacing=0 cellPadding=3 border=2>
  <TBODY>
  <TR>
    <TD>FFDE
    <TD>ROM mode
    <TD>Any write switches system ROMs into memory map </TD>
  <TR>
    <TD>FFDF
    <TD>RAM mode
    <TD>Any write selects all-RAM mode </TD></TR></TBODY></TABLE>
<P>
<HR>
<IMG height=21 src="Sock's GIME register reference_files/icon.gif" width=35 
align=top> Click <A href="http://www.axess.com/twilight/sock/">here</A> to 
return to Sock Master's Web Page. </FONT></BODY></HTML>
